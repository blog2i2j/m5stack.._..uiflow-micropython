Index: M5Unified/src/M5Unified.cpp
===================================================================
--- M5Unified.orig/src/M5Unified.cpp
+++ M5Unified/src/M5Unified.cpp
@@ -88,6 +88,7 @@ static constexpr const uint8_t _pin_tabl
 { board_t::board_unknown      , 255        ,255         , GPIO_NUM_0 ,GPIO_NUM_1  },
 #elif defined (CONFIG_IDF_TARGET_ESP32C6)
 { board_t::board_ArduinoNessoN1,GPIO_NUM_8 ,GPIO_NUM_10 , GPIO_NUM_8 ,GPIO_NUM_10 },
+{ board_t::board_M5UnitC6L     , 255       , 255        , 255        ,255         },
 { board_t::board_unknown      , 255        ,255         , GPIO_NUM_1 ,GPIO_NUM_2  }, // NanoC6
 #elif defined (CONFIG_IDF_TARGET_ESP32P4)
 { board_t::board_M5Tab5       , GPIO_NUM_32,GPIO_NUM_31, GPIO_NUM_54,GPIO_NUM_53 }, // Tab5
@@ -115,6 +116,7 @@ static constexpr const uint8_t _pin_tabl
 #elif defined (CONFIG_IDF_TARGET_ESP32C3)
 #elif defined (CONFIG_IDF_TARGET_ESP32C6)
 { board_t::board_ArduinoNessoN1,GPIO_NUM_4 ,GPIO_NUM_5 , 255        ,255         },
+{ board_t::board_M5UnitC6L     ,GPIO_NUM_4 ,GPIO_NUM_5 , 255        ,255         },
 #elif defined (CONFIG_IDF_TARGET_ESP32P4)
 { board_t::board_M5Tab5       , GPIO_NUM_17,GPIO_NUM_52, GPIO_NUM_7 ,GPIO_NUM_6  }, // Tab5
 #else
@@ -1320,6 +1322,36 @@ static constexpr const uint8_t _pin_tabl
         _io_expander[i].reset(ioexp);
       }
       break;
+    case board_t::board_M5UnitC6L:
+      {
+        In_SoftI2C.begin(10, 8);
+        auto ioexp = new PI4IOE5V6408_Class(0x43);
+        ioexp->begin();
+        _io_expander[0].reset(ioexp);
+        // user button(P0) input pullup 
+        _io_expander[0]->setDirection(0, false);
+        _io_expander[0]->setPullMode(0, true);
+        _io_expander[0]->setHighImpedance(0, false);
+        // sx1262 reset(P7)
+        _io_expander[0]->setDirection(7, true);
+        _io_expander[0]->setPullMode(7, false);
+        _io_expander[0]->setHighImpedance(7, false);
+        _io_expander[0]->digitalWrite(7, false);
+        delay(10);
+        _io_expander[0]->digitalWrite(7, true);
+        delay(10);
+        // LAN EN
+        _io_expander[0]->setDirection(5, true);
+        _io_expander[0]->setPullMode(5, false);
+        _io_expander[0]->setHighImpedance(5, false);
+        _io_expander[0]->digitalWrite(5, true);
+        // SW EN
+        _io_expander[0]->setDirection(6, true);
+        _io_expander[0]->setPullMode(6, false);
+        _io_expander[0]->setHighImpedance(6, false);
+        _io_expander[0]->digitalWrite(6, true);
+      }
+      break;
 #elif defined (CONFIG_IDF_TARGET_ESP32S3)
     case board_t::board_M5StampPLC:
       {
@@ -1679,7 +1711,14 @@ static constexpr const uint8_t _pin_tabl
           spk_cfg.magnification = 48;
         }
         break;
-
+      case board_t::board_M5UnitC6L:
+        if (cfg.internal_spk)
+        {
+          spk_cfg.pin_data_out = GPIO_NUM_11;
+          spk_cfg.buzzer = true;
+          spk_cfg.magnification = 16;
+        }
+        break;
 #elif defined (CONFIG_IDF_TARGET_ESP32P4)
       case board_t::board_M5Tab5:
         if (cfg.internal_spk)
@@ -2307,7 +2346,14 @@ static constexpr const uint8_t _pin_tabl
                         ;
       break;
     }
-
+    case board_t::board_M5UnitC6L:
+    {
+      use_rawstate_bits = 0b00001;
+      auto exp = static_cast<PI4IOE5V6408_Class*>(_io_expander[0].get());
+      uint8_t value = exp->readRegister8(0x0F);
+      btn_rawstate_bits = (!(value & 0b00001) ? 0b00001 : 0); // BtnA
+      break;
+    }
     default:
       break;
     }
Index: M5Unified/src/utility/IOExpander_Base.hpp
===================================================================
--- M5Unified.orig/src/utility/IOExpander_Base.hpp
+++ M5Unified/src/utility/IOExpander_Base.hpp
@@ -6,15 +6,28 @@
 
 #include <stdint.h>
 #include "I2C_Class.hpp"
+#if CONFIG_IDF_TARGET_ESP32C6
+#include "SoftI2C_Class.hpp"
+#endif
 
 namespace m5
 {
+
+#if CONFIG_IDF_TARGET_ESP32C6
+  class IOExpander_Base : public SoftI2C_Device
+  {
+  public:
+    IOExpander_Base(std::uint8_t i2c_addr, std::uint32_t freq = 400000, m5::SoftI2C_Class* i2c = &m5::In_SoftI2C)
+      : SoftI2C_Device(i2c_addr, freq, i2c)
+    {}
+#else
   class IOExpander_Base : public I2C_Device
   {
   public:
     IOExpander_Base(std::uint8_t i2c_addr, std::uint32_t freq = 400000, m5::I2C_Class* i2c = &m5::In_I2C)
       : I2C_Device(i2c_addr, freq, i2c)
     {}
+#endif
     IOExpander_Base(const IOExpander_Base&) = delete;
 
     // false input, true output
Index: M5Unified/src/utility/PI4IOE5V6408_Class.hpp
===================================================================
--- M5Unified.orig/src/utility/PI4IOE5V6408_Class.hpp
+++ M5Unified/src/utility/PI4IOE5V6408_Class.hpp
@@ -15,6 +15,9 @@
 
 #include "IOExpander_Base.hpp"
 #include "I2C_Class.hpp"
+#if CONFIG_IDF_TARGET_ESP32C6
+#include "SoftI2C_Class.hpp"
+#endif
 
 namespace m5
 {
@@ -24,9 +27,15 @@ namespace m5
   public:
     static constexpr std::uint8_t DEFAULT_ADDRESS = 0x43;
 
+#if CONFIG_IDF_TARGET_ESP32C6
+    PI4IOE5V6408_Class(std::uint8_t i2c_addr = DEFAULT_ADDRESS, std::uint32_t freq = 400000, m5::SoftI2C_Class* i2c = &m5::In_SoftI2C)
+    : IOExpander_Base(i2c_addr, freq, i2c)
+    {}
+#else
     PI4IOE5V6408_Class(std::uint8_t i2c_addr = DEFAULT_ADDRESS, std::uint32_t freq = 400000, m5::I2C_Class* i2c = &m5::In_I2C)
     : IOExpander_Base(i2c_addr, freq, i2c)
     {}
+#endif
 
     bool begin();
 
Index: M5Unified/src/utility/SoftI2C_Class.cpp
===================================================================
--- /dev/null
+++ M5Unified/src/utility/SoftI2C_Class.cpp
@@ -0,0 +1,479 @@
+// Copyright (c) M5Stack. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#include "SoftI2C_Class.hpp"
+#include <cstring>
+#include "driver/gpio.h"
+#include "esp_rom_sys.h"
+
+
+namespace m5
+{
+  SoftI2C_Class In_SoftI2C;
+
+  SoftI2C_Class::SoftI2C_Class()
+  {
+    _pin_sda = -1;
+    _pin_scl = -1;
+    _freq = 100000; // default 100kHz
+    _delay_us = 5;
+  }
+
+  SoftI2C_Class::~SoftI2C_Class()
+  {
+    release();
+  }
+
+  void SoftI2C_Class::setPins(int pin_sda, int pin_scl)
+  {
+    _pin_sda = pin_sda;
+    _pin_scl = pin_scl;
+  }
+
+  bool SoftI2C_Class::begin(int pin_sda, int pin_scl)
+  {
+    setPins(pin_sda, pin_scl);
+    return begin();
+  }
+
+  bool SoftI2C_Class::begin(void)
+  {
+    if (_pin_sda < 0 || _pin_scl < 0) {
+      return false;
+    }
+
+    gpio_config_t scl_conf = {};
+    scl_conf.pin_bit_mask = (1ULL << _pin_scl);
+    scl_conf.mode = GPIO_MODE_OUTPUT_OD;
+    scl_conf.pull_up_en = GPIO_PULLUP_ENABLE;
+    scl_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
+    scl_conf.intr_type = GPIO_INTR_DISABLE;
+    esp_err_t ret = gpio_config(&scl_conf);
+    if (ret != ESP_OK) {
+      return false;
+    }
+
+    gpio_config_t sda_conf = {};
+    sda_conf.pin_bit_mask = (1ULL << _pin_sda);
+    sda_conf.mode = GPIO_MODE_INPUT_OUTPUT_OD;
+    sda_conf.pull_up_en = GPIO_PULLUP_ENABLE;
+    sda_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
+    sda_conf.intr_type = GPIO_INTR_DISABLE;
+    ret = gpio_config(&sda_conf);
+    if (ret != ESP_OK) {
+      return false;
+    }
+
+    _delay_us = (uint32_t)((1e6f / _freq) / 2.0f + 0.5f);
+    if (_delay_us < 1) _delay_us = 1;
+
+    return true;
+  }
+
+  bool SoftI2C_Class::release(void) const
+  {
+    if (_pin_sda >= 0) {
+      gpio_set_direction((gpio_num_t)_pin_sda, GPIO_MODE_INPUT);
+    }
+    if (_pin_scl >= 0) {
+      gpio_set_direction((gpio_num_t)_pin_scl, GPIO_MODE_INPUT);
+    }
+    return true;
+  }
+
+  void SoftI2C_Class::_delay() const
+  {
+    esp_rom_delay_us(_delay_us);
+  }
+
+  void SoftI2C_Class::_scl_high() const
+  {
+    gpio_set_level((gpio_num_t)_pin_scl, 1);
+  }
+
+  void SoftI2C_Class::_scl_low() const
+  {
+    gpio_set_level((gpio_num_t)_pin_scl, 0);
+  }
+
+  void SoftI2C_Class::_sda_high() const
+  {
+    gpio_set_level((gpio_num_t)_pin_sda, 1);
+  }
+
+  void SoftI2C_Class::_sda_low() const
+  {
+    gpio_set_level((gpio_num_t)_pin_sda, 0);
+  }
+
+  bool SoftI2C_Class::_sda_read() const
+  {
+    return gpio_get_level((gpio_num_t)_pin_sda) == 1;
+  }
+
+  bool SoftI2C_Class::_i2c_start() const
+  {
+    _sda_high();
+    _scl_high();
+    _delay();
+    
+    _sda_low();
+    _delay();
+    
+    _scl_low();
+    _delay();
+    
+    return true;
+  }
+
+  bool SoftI2C_Class::_i2c_stop() const
+  {
+    _sda_low();
+    _delay();
+    
+    _scl_high();
+    _delay();
+    
+    _sda_high();
+    _delay();
+    
+    return true;
+  }
+
+  bool SoftI2C_Class::_i2c_write_byte(uint8_t data) const
+  {
+    for (int i = 7; i >= 0; i--) {
+      if (data & (1 << i)) {
+        _sda_high();
+      } else {
+        _sda_low();
+      }
+      _delay();
+      
+      _scl_high();
+      _delay();
+      
+      _scl_low();
+      _delay();
+    }
+    
+    _sda_high();
+    _delay();
+    
+    _scl_high();
+    _delay();
+    
+    bool ack = !_sda_read();
+    
+    _scl_low();
+    _delay();
+    
+    return ack;
+  }
+
+  uint8_t SoftI2C_Class::_i2c_read_byte(bool ack) const
+  {
+    uint8_t data = 0;
+    
+    _sda_high();
+    
+    for (int i = 7; i >= 0; i--) {
+      _scl_high();
+      _delay();
+      
+      if (_sda_read()) {
+        data |= (1 << i);
+      }
+      
+      _scl_low();
+      _delay();
+    }
+    
+    if (ack) {
+      _sda_low();
+    } else {
+      _sda_high();
+    }
+    _delay();
+    
+    _scl_high();
+    _delay();
+    _scl_low();
+    _delay();
+    
+    return data;
+  }
+
+  bool SoftI2C_Class::start(std::uint8_t address, bool read, std::uint32_t freq) const
+  {
+    if (_pin_sda < 0 || _pin_scl < 0) {
+      return false;
+    }
+
+    if (freq > 0) {
+      _delay_us = (uint32_t)((1e6f / freq) / 2.0f + 0.5f);
+      if (_delay_us < 1) _delay_us = 1;
+    }
+
+    if (!_i2c_start()) {
+      return false;
+    }
+
+    uint8_t address_byte = (address << 1) | (read ? 1 : 0);
+    if (!_i2c_write_byte(address_byte)) {
+      _i2c_stop();
+      return false;
+    }
+
+    return true;
+  }
+
+  bool SoftI2C_Class::restart(std::uint8_t address, bool read, std::uint32_t freq) const
+  {
+    return start(address, read, freq);
+  }
+
+  bool SoftI2C_Class::stop(void) const
+  {
+    if (_pin_sda < 0 || _pin_scl < 0) {
+      return false;
+    }
+
+    return _i2c_stop();
+  }
+
+  bool SoftI2C_Class::write(std::uint8_t data) const
+  {
+    if (_pin_sda < 0 || _pin_scl < 0) {
+      return false;
+    }
+
+    return _i2c_write_byte(data);
+  }
+
+  bool SoftI2C_Class::write(const std::uint8_t* data, std::size_t length) const
+  {
+    if (_pin_sda < 0 || _pin_scl < 0) {
+      return false;
+    }
+
+    if (!data || length == 0) {
+      return true;
+    }
+
+    for (std::size_t i = 0; i < length; i++) {
+      if (!_i2c_write_byte(data[i])) {
+        return false;
+      }
+    }
+
+    return true;
+  }
+
+  bool SoftI2C_Class::read(std::uint8_t* result, std::size_t length, bool last_nack) const
+  {
+    if (_pin_sda < 0 || _pin_scl < 0) {
+      return false;
+    }
+
+    if (!result || length == 0) {
+      return true;
+    }
+
+    for (std::size_t i = 0; i < length; i++) {
+      bool send_ack = (i != length - 1) || !last_nack;
+      result[i] = _i2c_read_byte(send_ack);
+    }
+
+    return true;
+  }
+
+  bool SoftI2C_Class::writeRegister(std::uint8_t address, std::uint8_t reg, const std::uint8_t* data, std::size_t length, std::uint32_t freq) const
+  {
+    if (_pin_sda < 0 || _pin_scl < 0) {
+      return false;
+    }
+
+    if (freq > 0) {
+      _delay_us = (uint32_t)((1e6f / freq) / 2.0f + 0.5f);
+      if (_delay_us < 1) _delay_us = 1;
+    }
+
+    if (!_i2c_start()) {
+      return false;
+    }
+
+    uint8_t address_byte = (address << 1) | 0;
+    if (!_i2c_write_byte(address_byte)) {
+      _i2c_stop();
+      return false;
+    }
+
+    if (!_i2c_write_byte(reg)) {
+      _i2c_stop();
+      return false;
+    }
+
+    for (std::size_t i = 0; i < length; i++) {
+      if (!_i2c_write_byte(data[i])) {
+        _i2c_stop();
+        return false;
+      }
+    }
+
+    // 发送 STOP 信号
+    _i2c_stop();
+    return true;
+  }
+
+  bool SoftI2C_Class::readRegister(std::uint8_t address, std::uint8_t reg, std::uint8_t* result, std::size_t length, std::uint32_t freq) const
+  {
+    if (_pin_sda < 0 || _pin_scl < 0) {
+      return false;
+    }
+
+    if (freq > 0) {
+      _delay_us = (uint32_t)((1e6f / freq) / 2.0f + 0.5f);
+      if (_delay_us < 1) _delay_us = 1;
+    }
+
+    if (!_i2c_start()) {
+      return false;
+    }
+
+    uint8_t address_byte = (address << 1) | 0;
+    if (!_i2c_write_byte(address_byte)) {
+      _i2c_stop();
+      return false;
+    }
+
+    if (!_i2c_write_byte(reg)) {
+      _i2c_stop();
+      return false;
+    }
+
+    if (!_i2c_start()) {
+      return false;
+    }
+
+    address_byte = (address << 1) | 1;
+    if (!_i2c_write_byte(address_byte)) {
+      _i2c_stop();
+      return false;
+    }
+
+    for (std::size_t i = 0; i < length; i++) {
+      bool send_ack = (i != length - 1);
+      result[i] = _i2c_read_byte(send_ack);
+    }
+
+    _i2c_stop();
+    return true;
+  }
+
+  bool SoftI2C_Class::writeRegister8(std::uint8_t address, std::uint8_t reg, std::uint8_t data, std::uint32_t freq) const
+  {
+    return writeRegister(address, reg, &data, 1, freq);
+  }
+
+  std::uint8_t SoftI2C_Class::readRegister8(std::uint8_t address, std::uint8_t reg, std::uint32_t freq) const
+  {
+    std::uint8_t result = 0;
+    if (!readRegister(address, reg, &result, 1, freq)) {
+      return 0;
+    }
+    return result;
+  }
+
+  bool SoftI2C_Class::bitOn(std::uint8_t address, std::uint8_t reg, std::uint8_t data, std::uint32_t freq) const
+  {
+    std::uint8_t current = readRegister8(address, reg, freq);
+    if (current == 0 && !readRegister(address, reg, &current, 1, freq)) {
+      return false;
+    }
+    return writeRegister8(address, reg, current | data, freq);
+  }
+
+  bool SoftI2C_Class::bitOff(std::uint8_t address, std::uint8_t reg, std::uint8_t data, std::uint32_t freq) const
+  {
+    std::uint8_t current = readRegister8(address, reg, freq);
+    if (current == 0 && !readRegister(address, reg, &current, 1, freq)) {
+      return false;
+    }
+    return writeRegister8(address, reg, current & ~data, freq);
+  }
+
+  void SoftI2C_Class::scanID(bool* result, std::uint32_t freq) const
+  {
+    if (!result) {
+      return;
+    }
+
+    std::memset(result, false, 120);
+
+    if (_pin_sda < 0 || _pin_scl < 0) {
+      return;
+    }
+
+    if (freq > 0) {
+      _delay_us = (uint32_t)((1e6f / freq) / 2.0f + 0.5f);
+      if (_delay_us < 1) _delay_us = 1;
+    }
+
+    for (int addr = 0x03; addr < 0x78; addr++) {
+      if (scanID(addr, freq)) {
+        result[addr] = true;
+      }
+    }
+  }
+
+  bool SoftI2C_Class::scanID(uint8_t addr, std::uint32_t freq) const
+  {
+    if (_pin_sda < 0 || _pin_scl < 0) {
+      return false;
+    }
+
+    if (freq > 0) {
+      _delay_us = (uint32_t)((1e6f / freq) / 2.0f + 0.5f);
+      if (_delay_us < 1) _delay_us = 1;
+    }
+
+    if (!_i2c_start()) {
+      return false;
+    }
+
+    uint8_t address_byte = (addr << 1) | 0;
+    bool ack = _i2c_write_byte(address_byte);
+    
+    _i2c_stop();
+    
+    return ack;
+  }
+
+  bool SoftI2C_Device::writeRegister8Array(const std::uint8_t* reg_data_array, std::size_t length) const
+  {
+    if (!_i2c || !reg_data_array || length == 0) {
+      return false;
+    }
+
+    if (!_i2c->start(_addr, false, _freq)) {
+      return false;
+    }
+
+    for (std::size_t i = 0; i < length; i += 2) {
+      if (i + 1 < length) {
+        if (!_i2c->write(reg_data_array[i])) {
+          _i2c->stop();
+          return false;
+        }
+        if (!_i2c->write(reg_data_array[i + 1])) {
+          _i2c->stop();
+          return false;
+        }
+      }
+    }
+
+    return _i2c->stop();
+  }
+
+} // namespace m5
Index: M5Unified/src/utility/SoftI2C_Class.hpp
===================================================================
--- /dev/null
+++ M5Unified/src/utility/SoftI2C_Class.hpp
@@ -0,0 +1,214 @@
+// Copyright (c) M5Stack. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#ifndef __M5_SOFT_I2C_CLASS_H__
+#define __M5_SOFT_I2C_CLASS_H__
+
+#include <driver/gpio.h>
+#include <cstdint>
+#include <cstddef>
+
+namespace m5
+{
+  class SoftI2C_Class
+  {
+  public:
+    /// Constructor
+    SoftI2C_Class();
+    
+    /// Destructor
+    ~SoftI2C_Class();
+
+    /// setup I2C pin parameters. (No begin)
+    /// @param pin_sda SDA pin number.
+    /// @param pin_scl SCL pin number.
+    void setPins(int pin_sda, int pin_scl);
+
+    /// setup and begin I2C peripheral. (No communication is performed.)
+    /// @param pin_sda SDA pin number.
+    /// @param pin_scl SCL pin number.
+    /// @return success(true) or failed(false).
+    bool begin(int pin_sda, int pin_scl);
+
+    /// begin I2C peripheral. (No communication is performed.)
+    /// @return success(true) or failed(false).
+    bool begin(void);
+
+    /// release I2C peripheral.
+    /// @return success(true) or failed(false).
+    bool release(void) const;
+
+    /// Sends the I2C start condition and the address of the slave.
+    /// @param address slave addr.
+    /// @param read bit of read flag. true=read / false=write.
+    /// @return success(true) or failed(false).
+    bool start(std::uint8_t address, bool read, std::uint32_t freq) const;
+
+    /// Sends the I2C repeated start condition and the address of the slave.
+    /// @param address slave addr.
+    /// @param read bit of read flag. true=read / false=write.
+    /// @return success(true) or failed(false).
+    bool restart(std::uint8_t address, bool read, std::uint32_t freq) const;
+
+    /// Sends the I2C stop condition.
+    /// If an ACK error occurs, return false.
+    /// @return success(true) or failed(false).
+    bool stop(void) const;
+
+    /// Send 1 byte of data.
+    /// @param data write data.
+    /// @return success(true) or failed(false).
+    bool write(std::uint8_t data) const;
+
+    /// Send multiple bytes of data.
+    /// @param[in] data write data array.
+    /// @param     length data array length.
+    /// @return success(true) or failed(false).
+    bool write(const std::uint8_t* data, std::size_t length) const;
+
+    /// Receive multiple bytes of data.
+    /// @param[out] result read data array.
+    /// @param      length data array length.
+    /// @return success(true) or failed(false).
+    bool read(std::uint8_t* result, std::size_t length, bool last_nack = false) const;
+
+    //----------
+
+    /// Write multiple bytes value to the register. Performs a series of communications from START to STOP.
+    /// @param address slave addr.
+    /// @param reg     register number.
+    /// @param[in] data write data array.
+    /// @param     length data array length.
+    /// @return success(true) or failed(false).
+    bool writeRegister(std::uint8_t address, std::uint8_t reg, const std::uint8_t* data, std::size_t length, std::uint32_t freq) const;
+
+    /// Read multiple bytes value from the register. Performs a series of communications from START to STOP.
+    /// @param address slave addr.
+    /// @param reg     register number.
+    /// @param[out] result read data array.
+    /// @param      length data array length.
+    /// @return success(true) or failed(false).
+    bool readRegister(std::uint8_t address, std::uint8_t reg, std::uint8_t* result, std::size_t length, std::uint32_t freq) const;
+
+    /// Write a 1-byte value to the register. Performs a series of communications from START to STOP.
+    /// @param address slave addr.
+    /// @param reg     register number.
+    /// @param data    write data.
+    /// @return success(true) or failed(false).
+    bool writeRegister8(std::uint8_t address, std::uint8_t reg, std::uint8_t data, std::uint32_t freq) const;
+
+    /// Read a 1-byte value from the register. Performs a series of communications from START to STOP.
+    /// @param address slave addr.
+    /// @param reg     register number.
+    /// @return read value.
+    std::uint8_t readRegister8(std::uint8_t address, std::uint8_t reg, std::uint32_t freq) const;
+
+    /// Write a 1-byte value to the register by bit add operation. Performs a series of communications from START to STOP.
+    /// @param address slave addr.
+    /// @param reg     register number.
+    /// @param data    add bit data.
+    /// @return success(true) or failed(false).
+    bool bitOn(std::uint8_t address, std::uint8_t reg, std::uint8_t data, std::uint32_t freq) const;
+
+    /// Write a 1-byte value to the register by bit erase operation. Performs a series of communications from START to STOP.
+    /// @param address slave addr.
+    /// @param reg     register number.
+    /// @param data    erase bit data.
+    /// @return success(true) or failed(false).
+    bool bitOff(std::uint8_t address, std::uint8_t reg, std::uint8_t data, std::uint32_t freq) const;
+
+    /// execute I2C scan. (for 7bit address)
+    /// @param[out] result data array needs 120 Bytes.
+    void scanID(bool* result, std::uint32_t freq = 100000) const;
+
+    bool scanID(uint8_t addr, std::uint32_t freq = 100000) const;
+
+    int8_t getSDA(void) const { return _pin_sda; }
+    int8_t getSCL(void) const { return _pin_scl; }
+    uint32_t getFrequency(void) const { return _freq; }
+
+    bool isEnabled(void) const { return _pin_sda >= 0 && _pin_scl >= 0; }
+
+  private:
+    int8_t _pin_sda = -1;
+    int8_t _pin_scl = -1;
+    uint32_t _freq = 100000;
+    mutable uint32_t _delay_us = 5;
+
+    void _delay() const;
+    void _scl_high() const;
+    void _scl_low() const;
+    void _sda_high() const;
+    void _sda_low() const;
+    bool _sda_read() const;
+    bool _i2c_start() const;
+    bool _i2c_stop() const;
+    bool _i2c_write_byte(uint8_t data) const;
+    uint8_t _i2c_read_byte(bool ack) const;
+  };
+
+  /// for internal I2C device
+  extern SoftI2C_Class In_SoftI2C;
+
+  class SoftI2C_Device
+  {
+  public:
+    SoftI2C_Device(std::uint8_t i2c_addr, std::uint32_t freq, SoftI2C_Class* i2c = &In_SoftI2C)
+    : _i2c   { i2c      }
+    , _freq  { freq     }
+    , _addr  { i2c_addr }
+    , _init  { false    }
+    {}
+
+    void setPort(SoftI2C_Class* i2c) { _i2c = i2c; }
+
+    void setClock(std::uint32_t freq) { _freq = freq; }
+
+    void setAddress(std::uint8_t i2c_addr) { _addr = i2c_addr; }
+
+    std::uint8_t getAddress(void) const { return _addr; }
+
+    bool writeRegister8(std::uint8_t reg, std::uint8_t data) const
+    {
+      return _i2c->writeRegister8(_addr, reg, data, _freq);
+    }
+
+    std::uint8_t readRegister8(std::uint8_t reg) const
+    {
+      return _i2c->readRegister8(_addr, reg, _freq);
+    }
+
+    bool writeRegister8Array(const std::uint8_t* reg_data_array, std::size_t length) const;
+
+    bool writeRegister(std::uint8_t reg, const std::uint8_t* data, std::size_t length) const
+    {
+      return _i2c->writeRegister(_addr, reg, data, length, _freq);
+    }
+
+    bool readRegister(std::uint8_t reg, std::uint8_t* result, std::size_t length) const
+    {
+      return _i2c->readRegister(_addr, reg, result, length, _freq);
+    }
+
+    bool bitOn(std::uint8_t reg, std::uint8_t bit) const
+    {
+      return _i2c->bitOn(_addr, reg, bit, _freq);
+    }
+
+    bool bitOff(std::uint8_t reg, std::uint8_t bit) const
+    {
+      return _i2c->bitOff(_addr, reg, bit, _freq);
+    }
+
+    bool isEnabled(void) const { return _init; }
+
+  protected:
+    SoftI2C_Class *_i2c;
+    std::uint32_t _freq;
+    std::uint8_t _addr;
+    bool _init;
+  };
+
+}
+
+#endif
